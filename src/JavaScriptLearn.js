/*
 * JavaScript的6大基本类型：
 *  1. String
 *  2. Number
 *  3. Boolean
 *  4. Undefined
 *  5. Null
 *  6. Object
 */


/**
 * String字符串
 *  - 在JS中字符串需要使用引号引起来
 *  - 使用双引号或单引号都可以，但不要混着用
 */
var str = "hello";
str = "world";

/**
 * Number数字
 * 在JS中所有的数值都是Number类型，包括整数和浮点数（小数）
 *
 * JS中Number的最大值：Number.MAX_VALUE
 * JS中Number正数的最小值：Number.MIN_VALUE
 * 如果Number表示的数字超过了Number.MAX_VALUE，则：使用Infinity（正无穷）
 * 如果Number返回的值为NaN（Not a Number），则：表示不是一个数字
 *
 * 如果使用JS进行浮点数计算，则：得到的结果可能不精确
 * 算钱的时候千万不要使用JS
 *
 * 可以使用typeof来检查一个变量的类型
 * 语法：typeof(表达式)和typeof 变量名
 */
var num = 123;


/**
 * Boolean布尔值
 * 布尔值只有两个：true和false
 */
var bool = true;

/**
 * Null
 * Null类型的值就只有一个：null
 * null专门用来表示一个为空的对象
 *
 * 使用typeof检查null时，会返回一个object
 */
var emptyObj = null;

/**
 * Undefined
 * Undefined类型的值也就只有一个：undefined
 * 当声明一个变量但不给变量赋值时，那么它的值就是undefined
 */
var undefined;


/**
 * 强制类型转换
 * 指将一个数据类型强制转换为其他的数据类型
 * 这里的类型转换是Number、String、Boolean互转
 *
 * 转换为String：
 *      方式一：调用被转换数据类型的toString()方法
 *             该方法不会影响到原变量，它会将转换的结果返回
 *             注意：null和undefined这两个值没有toString方法，如果调用的话会报错
 *
 *      方式二：调用String()函数
 *              使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用toString()方法
 *             但是对于null和undefined，就不会调用toString()方法，它会将null直接转为"null"，将undefined转为"undefined"
 *
 * 转换为Number：
 *      方式一：调用Number()函数
 *             1. 字符串：如果字符串为纯数字，则：直接转换；如果字符串为空或全是空格，则：转为0；其他情况为：NaN
 *             2. 布尔：true转为1，False转为0
 *             3. Null转为0
 *             4. Undefined转为NaN
 *
 *      方式二：专门用来对付字符串
 *             parseInt() 调用该函数将字符串转为int类型，字符串从左开始读起，遇到非数字停止
 *             parseFloat() 调用该函数将字符串转为float类型，字符串从左开始读起，遇到非数字停止
 *
 * 转换为Boolean：
 *      使用Boolean()函数
 *      1. 数字转Boolean：除了0和NaN，其余的都是true
 *      2. 字符串转Boolean：除了空串，其余都是true
 *      3. null和undefined转为false
 *      4. 对象转为true
 */
var numToStr = 123;
numToStr = numToStr.toString()

var strToNum = "123"
strToNum = Number(strToNum)
strToNum = parseInt(strToNum)

/**
 * 其他进制的数字
 *
 * 16进制：0x开头
 * 8进制：0开头
 * 2进制：0b开头
 */

/**
 * 运算符也叫做操作符
 * 通过运算符可以对一个或多个值进行运算，并获取运算结果
 *
 * 算术运算符：
 *      任何值和NaN运算都是NaN
 *      非Number类型的，会先转换为Number类型再进行计算
 *
 *      +：可以对两个值进行加法运算，并将结果返回。
 *          特例：两个字符串相加会是将字符串拼接起来
 *               任何值和字符串相加，都会先转为字符串，然后再相加
 *      -：可以对两个值进行减法运算，并将结果返回
 *      *：可以对两个值进行乘法运算，并将结果返回
 *      /：可以对两个值进行除法运算，并将结果返回
 *      %：可以对两个值进行取模运算，并将结果返回
 *      注意：除了 + ，其余方法与字符串计算时，都是转为Number类型再计算
 */


/**
 * 一元运算符，只需要一个操作数
 * + 正号：
 * - 负号：对数字去反，如果是非Number类型的，那么会先转为Number，然后取反
 *
 *
 */
var a = 1 + 1;

/**
 * 自增：通过自增可以使变量在自身的基础上增加1
 * 无论是a++，还是++a，都会立即使原变量的值自增1
 * 不同的是a++的值和++a的值不同，++a返回自增后的值，a++返回自增前的值
 *
 * 自减：通过自增可以使变量在自身的基础上减少1
 * 与自增一样，只不过逻辑相反
 */
var a = 1;
a++;
++a;

/**
 * 逻辑运算符
 * JS中有三种逻辑运算符：!非 &&与 ||或
 *
 * !：对bool值取反。如果是number，会先转为bool再取反
 * &&：当两个值都为true时，返回true，否则false
 * ||：当两个值都为false时，返回false，否则true
 *
 */

/**
 * 赋值运算符：
 *  a += 1, a = a + 1
 *  a -= 1, a = a - 1
 *  a *= 1, a = a * 1
 *  a /= 1, a = a / 1
 *  a %= 1, a = a % 1
 */

/**
 * 通过关系运算符可以比较两个值之间的大小关系
 * > 大于号：判断左侧的值是否大于右侧的值，成立返回true，否则false
 * < 小于号：判断左侧的值是否小于右侧的值，成立返回true，否则false
 * >= 大于等于号：判断左侧的值是否大于等于右侧的值，成立返回true，否则false
 * <= 小于等于号：判断左侧的值是否小于等于右侧的值，成立返回true，否则false
 * == 等于号：判断左侧的值是否等于右侧的值，成立返回true，否则false
 *    1. NaN不和任何职相等，包括他自身。使用isNaN()判断是否为NaN
 *    2. null和undefined相等
 *    3. 不同类型的数据进行比较时，会转为Number来进行比较
 * != 不等于：判断左侧的值是否不等于右侧的值，成立返回true，否则false
 * === 全等于：判断一个值是否全等，与相等类似，但是不会进行类型转换
 * !== 不全等：判断一个值是否不全等，与不等类似，但是不会进行类型转换
 *
 * 非数值比较：
 *      1. NaN和任意值比较都是false
 *      2. 如果符号两侧的值都是字符串，则会比较字符的编码。当两个字符一样时，则比较下一位
 */


/**
 * 条件运算符也叫三元运算符
 * 语法：
 *      条件表达式 ? 语句1 : 语句2;
 *
 * 执行流程：
 *      条件运算符在执行时，首先对条件表达式进行求值：true执行语句1，并返回语句1的结果；false执行语句2，并返回语句2的结果
 *
 * 当条件表达式不是布尔值时，会转为布尔值
 */
var a = 'abc' > 'bcd' ? 'aaa' : 'bbb';


/**
 * ,可以实现一行写多条语句
 */
/**
 * if语句
 *      语法一：
 *          if (条件表达式)
 *              语句;
 *
 *          if语句在执行时，会先对条件表达式进行求值判断，
 *          如果条件表达式的值为true，则执行if后的语句，
 *          如果条件表达式的值为false，则不会执行if后的语句。
 *
 *          if语句只能控制紧跟后面的一条语句，如果想控制多条语句，可以将多条语句放到代码块中。
 *
 *     语法二：
 *          if (条件表达式){
 *              语句1;
 *          }else{
 *              语句2;
 *          }
 *
 *          if语句在执行时，会先对条件表达式进行求值判断，
 *          如果条件表达式的值为true，则执行if后的语句，
 *          如果条件表达式的值为false，则执行else后的语句。
 *
 *     语法三：
 *          if (条件表达式){
 *              语句1;
 *          }else if (条件表达式) {
 *              语句2;
 *          }else{
 *              语句3;
 *          }
 *
 */
if (true) {
    alert('执行语句');
}

/**
 * 条件分支语句：
 *      switch(条件表达式){
 *          case 表达式1：
 *              语句1;
 *              break;
 *          case 表达式2：
 *              语句2;
 *              break;
 *          case 表达式3：
 *              语句3;
 *              break;
 *          default：
 *              语句4;
 *      }
 *
 */
switch(a){
    case 1:
        alert(1);
        break;
    case 2:
        alert(1);
        break;
    case 3:
        alert(1);
        break;
    default:
        alert('default');
}

/**
 * 循环语句：循环语句可以反复的执行一段代码
 *
 * 循环需要三个步骤：1.创建初始化变量，2.在循环中设置一个条件表达式，3.更新初始化变量
 *
 * while循环：
 *      语法：
 *          while(条件表达式){
 *              语句;
 *          }
 *      执行流程：
 *          1. 先对条件表达式进行求值判断
 *          2. 如果值为true，则执行循环体
 *          3. 循环体执行完毕后，则：继续判断表达式条件
 *          4. 如果为true，则继续执行循环体
 *          5. 如果为false，则终止循环
 *
 * do...while循环：
 *      语法：
 *          do{
 *
 *          }while();
 *
 *      执行流程：
 *          1. 先执行循环体
 *          2. 判断循环条件
 *          3. 如果为true，则继续执行循环体
 *
 * for循环：
 *      语法：
 *          for(初始化表达式;条件表达式;更新表达式){
 *              语句;
 *          }
 *
 *      执行流程：
 *          1. 执行初始化表达式，初始化变量
 *          2. 执行条件表达式，判断是否执行循环。
 *          3. true执行循环体，false终止循环
 *          4. 执行更新表达式
 *          5. 重复第2步
 */
// 死循环，永远不会停止下来，除非浏览器关闭
while(true){

}

/**
 * break：用于控制跳出循环
 * continue：用于控制跳过当前循环，进行下一次循环
 */

/**
 * 对象：
 *      对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性
 *
 * 对象的分类：
 *      1. 内建对象：
 *              - 由ES标准定义的对象，在任何的ES实现中都可以使用
 *                例如：Math、String、Number、Boolean、Function、Object...
 *      2. 宿主对象：
 *              - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
 *                例如：DOM、BOM
 *      3. 自定义对象：
 *              - 由开发人员自己创建的对象
 */

/**
 * 创建对象：
 *      使用new关键字调用的函数，是构造函数constructor
 *      构造函数是专门用来创建对象的函数
 *
 *      语法：1. var obj = new Object();
 *           2. var obj = {};
 *           3. var obj = {attr1:"value1",attr2:"value2"};
 *
 *      使用typeof检查一个对象时，会返回object
 *
 * 属性：
 *      对象中保存的值称为属性
 *
 *      添加/修改属性：
 *          语法：对象.属性名 = 属性值;
 *               对象["属性名"] = 属性值;
 *          属性名不强制要求遵守标识符的规范
 *      获取属性：
 *          语法：对象.属性名
 *          注意：如果读取对象中没有的属性，不会报错而是会返回undefined
 *      删除属性：
 *          语法：delete 对象.属性名
 *
 * in:
 *      可以判断一个对象是否包含某个属性
 *      语法："属性名" in 对象
  * @type {Object}
 */
var obj = new Object();
obj.name = "ay";
obj.gender = "man";

console.log(obj.name);

delete obj.name;

/**
 * 函数：
 *      - 函数也是一个对象
 *      - 函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）
 *      - 函数中可以保存一些代码，在需要的时候调用
 *      - 使用typeof检查一个函数对象时，会返回function
 */

// 创建一个函数
//可以将要封装的代码以字符串的形式传递给构造函数
var func = new Function("console.log('Hello Function!')")

// 封装到函数中的代码不会立即执行，函数中的代码会在函数调用的时候执行
// 语法：函数对象()

/**
 * 使用 函数声明 创建一个函数
 * 语法：
 *      fcuntion 函数名([形参1,形参2,...,形参N]){
 *          语句;
 *      }
 */
function func2(){
    console.log("Hello function!")
}


/**
 * 使用 函数表达式 创建一个函数
 * var 函数名 = function([形参1,形参2,...,形参N]){
 *     语句...;
 * };
 */

/**
 * 枚举属性值
 * 语法：
 *      for(var 变量名 in 对象){
 *
 *      }
 */


/**
 * 作用域：
 *      - 作用域指一个变量的作用范围
 *      - 在JS中有两种作用域：
 *          1. 全局作用域：
 *              - 直接编写在script标签中的JS代码，都在全局作用域
 *              - 全局作用域在页面打开时创建，在页面关闭时销毁
 *              - 在全局作用域中有一个window对象，它代表的是一个浏览器窗口，它由浏览器创建我们可以直接使用
 *              - 在全局作用域中：
 *                  创建的变量都会作为window对象的属性保存
 *                  创建的函数都会作为window对象的方法保存
 *          2. 局部作用域（函数作用域）
 *              - 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
 *              - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
 *              - 在函数作用域中可以访问到全局作用域变量
 *
 * 变量声明提前：
 *      - 使用var关键字声明的变量，会在所有的代码执行之前被声明，但是不会赋值。
 *        如果声明变量时不使用var关键，则变量不会被声明提前
 *
 * 函数声明提前：
 *      - 使用函数声明形式创建的函数function 函数(){}，它会在所有的代码执行之前就被创建
 *
 */


/**
 * 解析器在调用函数时，每次都会向函数内部传递一个隐含参数：this
 * this对象称为函数执行的上下文对象
 * 根据函数的调用方式不同，this会指向不同的对象
 *      1. 以函数形式调用，this永远都是window
 *      2. 以方法的形式调用，this就是调用方法的那个对象
 */

/**
 * 构造函数：new 普通函数();
 * 执行流程：
 *      1. 立刻创建一个新的对象
 *      2. 将新建的对象设置为函数中的this
 *      3. 逐行执行函数中的代码
 *      4. 将新建的对象作为返回值返回
 */

/**
 * 原型对象：
 *      我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
 *      这个属性对应着一个对象，这个对象就是原型对象
 *
 * 如果函数作为普通函数调用，那么prototype没有任何作用
 * 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该对象
 *
 *
 * in：当对象没有属性时，但原型对象有时，依然返回true
 * hasOwnProperty：只会返回对象是否有该属性
 *
 * 原型对象也是对象，所以它也有原型
 *      当我们使用一个对象的属性或方法时，会先在自身中寻找，
 *      如果自身中有，则直接使用，
 *      如果没有，则去原型对象中寻找，如果原型对象中有，则：使用
 *      如果原型对象也没有，则：到原型对象的原型中寻找，直到找到Object对象的原型为止
 *      Object对象的原型没有原型，如果在Object中依然没有，则：返回undefined
 */

/**
 * 数组（Array）
 *      - 数组也是一个对象
 *      - 它和我们普通对象功能类似，也是用来存储一些值的
 *      - 不同的是普通对象使用字符串作为属性名的，而数组是使用数字来作为索引操作元素
 *      - 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据
 *
 * 索引：
 *      从0开始的整数就是索引
 *
 * 创建数组：
 *      var arr = new Array();
 *
 * 添加元素：
 *      数组[索引] = 值
 * 读取元素：
 *      数组[索引]
 */
// TODO 明天学习P48，https://www.bilibili.com/video/BV1YW411T7GX?p=48